import pandas as pd
import numpy as np

def find_offsetting_groups_fast(df, grca_col='grca_account', amount_col='adj_amount',
                                desc_col='adj_description', custom_cols=None, tol=1e-6):
    """
    Hybrid Greedy + Hash-based matching for offsetting adjustments.
    Matches +ve and -ve adjustments within each GRCA account and identifies changed customs.
    
    Returns: DataFrame with columns
        [grca_account, adj_description, adj_amount, changed_customs, changed_custom_values]
    """
    if custom_cols is None:
        custom_cols = [c for c in df.columns if c.startswith('custom_')]

    df = df.copy()
    df['_abs_amt'] = df[amount_col].abs().round(6)
    results = []

    for acc, grp in df.groupby(grca_col):
        grp = grp.reset_index(drop=True)
        grp['_used'] = False
        
        # --- (1) Hash-based quick matching for exact abs(amount) groups ---
        abs_groups = grp.groupby('_abs_amt')
        for _, g in abs_groups:
            if abs(g[amount_col].sum()) < tol and len(g) > 1:
                grp.loc[g.index, '_used'] = True
                diffs = []
                for c in custom_cols:
                    vals = g[c].dropna().unique()
                    if len(vals) > 1:
                        # Reverse direction of change
                        vals = list(map(str, vals))
                        if len(vals) == 2:
                            vals = vals[::-1]
                        diffs.append((c, " → ".join(vals)))
                changed_cols = [d[0] for d in diffs]
                changed_vals = [d[1] for d in diffs]
                for _, r in g.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: r[desc_col],
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(changed_cols) if changed_cols else None,
                        'changed_custom_values': ', '.join(changed_vals) if changed_vals else None
                    })
        
        # --- (2) Greedy matching for remaining unmatched entries ---
        rem = grp[~grp['_used']].sort_values(amount_col).reset_index()
        if rem.empty:
            continue

        pos = rem[rem[amount_col] > 0].to_dict('records')
        neg = rem[rem[amount_col] < 0].to_dict('records')

        i, j = 0, 0
        while i < len(pos) and j < len(neg):
            diff = pos[i][amount_col] + neg[j][amount_col]
            if abs(diff) <= tol:
                g = pd.DataFrame([pos[i], neg[j]])
                diffs = []
                for c in custom_cols:
                    vals = g[c].dropna().unique()
                    if len(vals) > 1:
                        # Reverse direction of change
                        vals = list(map(str, vals))
                        if len(vals) == 2:
                            vals = vals[::-1]
                        diffs.append((c, " → ".join(vals)))
                changed_cols = [d[0] for d in diffs]
                changed_vals = [d[1] for d in diffs]
                for _, r in g.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: r[desc_col],
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(changed_cols) if changed_cols else None,
                        'changed_custom_values': ', '.join(changed_vals) if changed_vals else None
                    })
                i += 1
                j += 1
            elif diff > 0:
                pos[i][amount_col] = diff
                j += 1
            else:
                neg[j][amount_col] = diff
                i += 1

    return pd.DataFrame(results)
