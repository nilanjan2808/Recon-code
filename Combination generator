import pandas as pd
import numpy as np

def find_offsetting_groups_final(df, grca_col='grca_account', desc_col='adj_description',
                                 amount_col='adj_amount', custom_cols=None, tol=1e-6):
    """
    Hybrid Hash + Greedy offsetting match finder.
    - Groups by GRCA + adj_description
    - First matches exact pairs, then split matches
    - Each original row appears once
    - Shows changed customs and their own row's values
    """
    if custom_cols is None:
        custom_cols = [c for c in df.columns if c.startswith('custom_')]

    df = df.copy()
    df['_abs_amt'] = df[amount_col].abs().round(6)
    df['_used'] = False

    results = []

    # Group by both GRCA and adj description
    for (acc, desc), grp in df.groupby([grca_col, desc_col]):
        grp = grp.reset_index(drop=True)
        grp['_used'] = False

        # -------- 1️⃣ Hash-based exact amount matching --------
        abs_groups = grp.groupby('_abs_amt')
        for _, g in abs_groups:
            # Check if sum of all entries is approx zero
            if abs(g[amount_col].sum()) < tol and len(g) > 1:
                grp.loc[g.index, '_used'] = True

                # Determine which customs differ
                diffs = [c for c in custom_cols if g[c].nunique(dropna=True) > 1]

                for _, r in g.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: desc,
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(diffs) if diffs else None,
                        'changed_custom_values': ', '.join(
                            str(r[c]) for c in diffs if pd.notna(r[c])
                        ) if diffs else None
                    })

        # -------- 2️⃣ Greedy matching for splits --------
        rem = grp[~grp['_used']].sort_values(amount_col).reset_index(drop=True)
        if not rem.empty:
            pos = rem[rem[amount_col] > 0].copy().to_dict('records')
            neg = rem[rem[amount_col] < 0].copy().to_dict('records')

            i, j = 0, 0
            while i < len(pos) and j < len(neg):
                diff = pos[i][amount_col] + neg[j][amount_col]
                if abs(diff) <= tol:
                    # Full offset found
                    g = pd.DataFrame([pos[i], neg[j]])
                    diffs = [c for c in custom_cols if g[c].nunique(dropna=True) > 1]
                    for _, r in g.iterrows():
                        results.append({
                            grca_col: acc,
                            desc_col: desc,
                            amount_col: r[amount_col],
                            'changed_customs': ', '.join(diffs) if diffs else None,
                            'changed_custom_values': ', '.join(
                                str(r[c]) for c in diffs if pd.notna(r[c])
                            ) if diffs else None
                        })
                    pos[i]['_used'] = True
                    neg[j]['_used'] = True
                    i += 1
                    j += 1
                elif diff > 0:
                    # Positive too large -> use part of it
                    neg[j][amount_col] = diff
                    j += 1
                else:
                    # Negative too large -> use part of it
                    pos[i][amount_col] = diff
                    i += 1

            # Add remaining unmatched
            rem_rows = [r for r in rem.to_dict('records') if not r.get('_used', False)]
            for r in rem_rows:
                results.append({
                    grca_col: acc,
                    desc_col: desc,
                    amount_col: r[amount_col],
                    'changed_customs': None,
                    'changed_custom_values': None
                })

    return pd.DataFrame(results)
