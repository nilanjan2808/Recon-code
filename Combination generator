import pandas as pd
import numpy as np

def find_offsetting_pairs_and_splits_clean(df, grca_col='grca_account', desc_col='adj_description',
                                           amount_col='adj_amount', custom_cols=None, tol=1e-6):
    """
    Hybrid Hash + Greedy offsetting logic.
    ✅ Tries 1-to-1 pairs first
    ✅ If no pairs found, then tries split combinations
    ✅ Keeps matched rows separate (not merged)
    ✅ Keeps unmatched rows as-is
    """
    if custom_cols is None:
        custom_cols = [c for c in df.columns if c.startswith('custom_')]

    df = df.copy()
    results = []

    # Group by GRCA + description
    for (acc, desc), grp in df.groupby([grca_col, desc_col]):
        grp = grp.reset_index(drop=True)

        # --- 1️⃣ Try exact pairs first ---
        matched_idx = set()
        abs_groups = grp.groupby(grp[amount_col].abs().round(6))

        for _, g in abs_groups:
            if len(g) == 2 and abs(g[amount_col].sum()) <= tol:
                # Found clean pair
                diffs = []
                for c in custom_cols:
                    vals = g[c].dropna().unique()
                    if len(vals) > 1:
                        diffs.append(c)
                for _, r in g.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: desc,
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(diffs) if diffs else None,
                        'changed_custom_values': ', '.join(str(r[c]) for c in diffs) if diffs else None
                    })
                matched_idx.update(g.index)

        # Remaining unmatched rows
        rem = grp.loc[~grp.index.isin(matched_idx)]
        if rem.empty:
            continue

        # --- 2️⃣ If no pairs matched, try split matches ---
        pos = rem[rem[amount_col] > 0].copy().reset_index(drop=True)
        neg = rem[rem[amount_col] < 0].copy().reset_index(drop=True)

        matched_any_split = False

        for i in range(len(pos)):
            for j in range(len(neg)):
                if abs(pos.iloc[i][amount_col]) <= tol or abs(neg.iloc[j][amount_col]) <= tol:
                    continue

                match_amt = min(pos.iloc[i][amount_col], -neg.iloc[j][amount_col])
                if match_amt <= tol:
                    continue

                # Mark as split match
                matched_any_split = True
                temp = pd.DataFrame([pos.iloc[i], neg.iloc[j]])
                diffs = []
                for c in custom_cols:
                    vals = temp[c].dropna().unique()
                    if len(vals) > 1:
                        diffs.append(c)
                for _, r in temp.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: desc,
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(diffs) if diffs else None,
                        'changed_custom_values': ', '.join(str(r[c]) for c in diffs) if diffs else None
                    })

                pos.at[i, amount_col] -= match_amt
                neg.at[j, amount_col] += match_amt

        # --- 3️⃣ If neither pairs nor splits, keep unmatched ---
        if not matched_any_split and not matched_idx:
            for _, r in rem.iterrows():
                results.append({
                    grca_col: acc,
                    desc_col: desc,
                    amount_col: r[amount_col],
                    'changed_customs': None,
                    'changed_custom_values': None
                })

    return pd.DataFrame(results)
