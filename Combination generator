import pandas as pd
from itertools import combinations

def find_balanced_groups(df, amount_col='adj_amount', group_cols=['grca_account', 'adj_description'], tol=1e-6):
    results = []
    
    # process each (grca_account, adj_description) combination
    for keys, group in df.groupby(group_cols):
        group = group.reset_index(drop=True)
        used = set()
        pos = group[group[amount_col] > 0]
        neg = group[group[amount_col] < 0]
        
        # Step 1: Direct hash match (exact opposite pairs)
        amt_map = {}
        for i, row in group.iterrows():
            val = round(row[amount_col], 6)
            if -val in amt_map and amt_map[-val] not in used:
                pair_idx = amt_map[-val]
                used.add(i); used.add(pair_idx)
                results.append(group.loc[[i, pair_idx]])
            else:
                amt_map[val] = i
        
        # Step 2: Greedy multi-split matches
        remaining = group.loc[~group.index.isin(used)]
        pos_rem = remaining[remaining[amount_col] > 0]
        neg_rem = remaining[remaining[amount_col] < 0]
        
        for neg_idx, neg_row in neg_rem.iterrows():
            target = -neg_row[amount_col]
            pos_indices = pos_rem.index.tolist()
            
            # Try combinations of positives
            for r in range(2, len(pos_indices) + 1):
                for combo in combinations(pos_indices, r):
                    combo_sum = pos_rem.loc[list(combo), amount_col].sum()
                    if abs(combo_sum - target) < tol:
                        used.update([neg_idx] + list(combo))
                        results.append(group.loc[[neg_idx] + list(combo)])
                        break
                if neg_idx in used:
                    break

    # Combine all results
    matched = pd.concat(results, ignore_index=True) if results else pd.DataFrame()
    return matched
