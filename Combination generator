import pandas as pd
import numpy as np

def find_offsetting_pairs_and_splits(df, grca_col='grca_account', desc_col='adj_description',
                                     amount_col='adj_amount', custom_cols=None, tol=1e-6):
    """
    Find +ve/-ve offsetting pairs or split matches within each (grca_account, adj_description).
    Each matched portion (even from splits) appears as a separate row.
    Shows current rowâ€™s custom values, not arrows.
    """
    if custom_cols is None:
        custom_cols = [c for c in df.columns if c.startswith('custom_')]

    df = df.copy()
    results = []

    # Group by both GRCA account and adj description
    for (acc, desc), grp in df.groupby([grca_col, desc_col]):
        grp = grp.reset_index(drop=True)

        pos = grp[grp[amount_col] > 0].copy()
        neg = grp[grp[amount_col] < 0].copy()

        pos['_remain'] = pos[amount_col].values
        neg['_remain'] = neg[amount_col].values

        # --- Exact +ve/-ve absolute match (fast path)
        abs_groups = grp.groupby(grp[amount_col].abs().round(6))
        used_idx = set()
        for _, g in abs_groups:
            if len(g) > 1 and abs(g[amount_col].sum()) <= tol:
                diffs = []
                for c in custom_cols:
                    vals = g[c].dropna().unique()
                    if len(vals) > 1:
                        diffs.append(c)
                for _, r in g.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: desc,
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(diffs) if diffs else None,
                        'changed_custom_values': ', '.join(str(r[c]) for c in diffs) if diffs else None
                    })
                used_idx.update(g.index)

        rem = grp.loc[~grp.index.isin(used_idx)]
        if rem.empty:
            continue

        # --- Greedy split matching for remaining ---
        pos = rem[rem[amount_col] > 0].copy()
        neg = rem[rem[amount_col] < 0].copy()

        for i in range(len(pos)):
            for j in range(len(neg)):
                if abs(pos.loc[i, amount_col]) <= tol or abs(neg.loc[j, amount_col]) <= tol:
                    continue

                # Amount that can be offset
                match_amt = min(pos.loc[i, amount_col], -neg.loc[j, amount_col])
                if match_amt <= tol:
                    continue

                # Record the pairing (partial if split)
                temp = pd.DataFrame([pos.loc[i], neg.loc[j]])
                diffs = []
                for c in custom_cols:
                    vals = temp[c].dropna().unique()
                    if len(vals) > 1:
                        diffs.append(c)
                for _, r in temp.iterrows():
                    results.append({
                        grca_col: acc,
                        desc_col: desc,
                        amount_col: r[amount_col],
                        'changed_customs': ', '.join(diffs) if diffs else None,
                        'changed_custom_values': ', '.join(str(r[c]) for c in diffs) if diffs else None
                    })

                # Reduce remaining amounts (simulate partial match)
                pos.loc[i, amount_col] -= match_amt
                neg.loc[j, amount_col] += match_amt  # since it's negative

        # --- Unmatched residuals ---
