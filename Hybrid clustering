import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans, DBSCAN
from sklearn.metrics import silhouette_score
from scipy.sparse import hstack
import matplotlib.pyplot as plt

def hybrid_clustering_text(df,
                           desc_col='adj_description',
                           custom_col='changed_customs',
                           custom_val_col='changed_custom_values',
                           max_k=10, eps=0.5, min_samples=3):
    """
    Performs three clustering methods on text/categorical features only:
      1. KMeans on one-hot encoded features
      2. KMeans on TF-IDF embeddings
      3. DBSCAN on one-hot features

    Returns:
      (clustered_df, cluster_metrics)
    """

    df = df.copy()
    df = df.dropna(subset=[desc_col])  # remove blanks

    # ---------- Step 1: One-hot encode categorical columns ----------
    cat_features = df[[desc_col, custom_col, custom_val_col]].astype(str).fillna('None')
    ohe = OneHotEncoder(sparse=True, handle_unknown='ignore')
    X_ohe = ohe.fit_transform(cat_features)

    # ---------- Step 2: TF-IDF features ----------
    text_data = (
        df[desc_col].astype(str) + " " +
        df[custom_col].astype(str) + " " +
        df[custom_val_col].astype(str)
    )
    tfidf = TfidfVectorizer(stop_words='english', max_features=1000)
    X_tfidf = tfidf.fit_transform(text_data)

    # ---------- Step 3: KMeans on OHE (Elbow + Silhouette) ----------
    inertia = []
    K = range(2, max_k + 1)
    for k in K:
        km = KMeans(n_clusters=k, random_state=42, n_init=10)
        km.fit(X_ohe)
        inertia.append(km.inertia_)

    plt.figure(figsize=(5, 3))
    plt.plot(K, inertia, 'bx-')
    plt.title('Elbow Method (KMeans on OHE)')
    plt.xlabel('k')
    plt.ylabel('Inertia')
    plt.show()

    optimal_k_ohe = np.diff(inertia, 2).argmin() + 2
    km_ohe = KMeans(n_clusters=optimal_k_ohe, random_state=42, n_init=10)
    labels_ohe = km_ohe.fit_predict(X_ohe)
    sil_ohe = silhouette_score(X_ohe, labels_ohe)
    print(f"✅ KMeans (OHE) Optimal Clusters = {optimal_k_ohe} | Silhouette = {sil_ohe:.3f}")

    # ---------- Step 4: KMeans on TF-IDF (Elbow + Silhouette) ----------
    inertia_tfidf = []
    for k in K:
        km = KMeans(n_clusters=k, random_state=42, n_init=10)
        km.fit(X_tfidf)
        inertia_tfidf.append(km.inertia_)

    plt.figure(figsize=(5, 3))
    plt.plot(K, inertia_tfidf, 'gx-')
    plt.title('Elbow Method (KMeans on TF-IDF)')
    plt.xlabel('k')
    plt.ylabel('Inertia')
    plt.show()

    optimal_k_tfidf = np.diff(inertia_tfidf, 2).argmin() + 2
    km_tfidf = KMeans(n_clusters=optimal_k_tfidf, random_state=42, n_init=10)
    labels_tfidf = km_tfidf.fit_predict(X_tfidf)
    sil_tfidf = silhouette_score(X_tfidf, labels_tfidf)
    print(f"✅ KMeans (TF-IDF) Optimal Clusters = {optimal_k_tfidf} | Silhouette = {sil_tfidf:.3f}")

    # ---------- Step 5: DBSCAN on OHE ----------
    dbscan = DBSCAN(eps=eps, min_samples=min_samples)
    labels_dbscan = dbscan.fit_predict(X_ohe)
    n_clusters_dbscan = len(set(labels_dbscan)) - (1 if -1 in labels_dbscan else 0)
    if n_clusters_dbscan > 1:
        sil_dbscan = silhouette_score(X_ohe, labels_dbscan)
    else:
        sil_dbscan = np.nan
    print(f"✅ DBSCAN Clusters = {n_clusters_dbscan} | Silhouette = {sil_dbscan}")

    # ---------- Step 6: Merge results ----------
    df['kmeans_cluster'] = labels_ohe
    df['tfidf_cluster'] = labels_tfidf
    df['dbscan_cluster'] = labels_dbscan

    metrics = {
        'kmeans_clusters': optimal_k_ohe,
        'tfidf_clusters': optimal_k_tfidf,
        'dbscan_clusters': n_clusters_dbscan,
        'silhouette_kmeans': sil_ohe,
        'silhouette_tfidf': sil_tfidf,
        'silhouette_dbscan': sil_dbscan
    }

    return df, metrics
